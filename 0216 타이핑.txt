set serveroutput on

--커서 FOR LOOP
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, last_name
        FROM employees;
        --WHERE employee_id = 0; WHERE 절 실행하면 출력안되고 이거 빼면 43건 출력됨.
BEGIN
    
    FOR emp_record IN emp_cursor LOOP -- 범위 지정에 커서 들어감
        DBMS_OUTPUT.PUT('NO. ' || emp_cursor%ROWCOUNT);
        DBMS_OUTPUT.PUT('사원번호 : ' || emp_record.employee_id);
        DBMS_OUTPUT.PUT_LINE(', 사원이름 : ' || emp_record.last_name);
    END LOOP; -- CLOSE; 와 같은 의미.
    --DBMS_OUTPUT.PUT_LINE('TOTAL : ' || emp_cursor%ROWCOUNT); END 여서 접근 불가능한 커서임.
    
    FOR dept_info IN (SELECT *
                        FROM departments) LOOP
        DBMS_OUTPUT.PUT(',부서번호 : ' || dept_info.department_id);
        DBMS_OUTPUT.PUT_LINE(', 부서이름 : ' || dept_info.department_name);
    END LOOP;
                        
END;
/

-- 1) 모든 사원의 사원번호, 이름, 부서이름 출력
DECLARE
    CURSOR  emp_cursor  IS
    SELECT employee_id eid, last_name ename, department_name dept_name
    FROM employees e
        LEFT OUTER JOIN departments d
        ON e.department_id = d.department_id;
        
BEGIN
    FOR  v_emp_info  IN   emp_cursor   LOOP
        DBMS_OUTPUT.PUT(v_emp_info.eid || ', ');
        DBMS_OUTPUT.PUT(v_emp_info.ename || ', ');
        DBMS_OUTPUT.PUT_LINE(v_emp_info.dept_name); 
    END LOOP;
END;
/

-- 2) 부서번호가 50이거나 80인 사원들의 사원이름, 급여, 연봉 츨력
DECLARE
    CURSOR emp_cursor IS
        SELECT last_name
                ,salary
                ,commission_pct
        FROM employees
        WHERE department_id IN (50, 80);
        
    v_annual NUMBER(10,0);
BEGIN
    FOR v_emp_info   IN  emp_cursor    LOOP
        v_annual :=(v_emp_info.salary * 12) + (NVL(v_emp_info.salary, 0) * NVL(v_emp_info.commission_pct,0)*12);
        DBMS_OUTPUT.PUT_LINE(( v_emp_info.last_name || ', ' || v_emp_info.salary|| ', ' || v_annual ));     
    END LOOP;
END;
/


--매개변수 사용 커서
DECLARE
    CURSOR emp_cursor --커서이름
        ( p_mgr employees.manager_id%TYPE ) IS
            SELECT *
            FROM employees
            WHERE manager_id = p_mgr; --SELECT 문의 p_mgr 가 미완성
    v_emp_info emp_cursor%ROWTYPE;

BEGIN
    --기본
    OPEN emp_cursor(100); --커서 오픈할 때 매개변수 넣어줄것. 이게 비어있는 값임을 알림..
    
    LOOP
        FETCH emp_cursor INTO v_emp_info ;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT(v_emp_info.employee_id || ', ');
        DBMS_OUTPUT.PUT_LINE(v_emp_info.last_name || ', '); 
    END LOOP;
    
    CLOSE emp_cursor ;
    
    --커서 FOR LOOP    
    FOR emp_info IN emp_cursor(149) LOOP
        DBMS_OUTPUT.PUT(emp_info.employee_id || ', ');
        DBMS_OUTPUT.PUT_LINE(emp_info.last_name || ', '); 
    END LOOP;    
    
END;
/

--문제풀이 1.
--사원(employees) 테이블에서 사원의 사원번호, 사원이름, 입사연도를 다음 기준에 맞게 각각 test01, test02 에 입력하시오.
--입사년도가 2015년 (포함) 이전 입사한 사원은 test01 테이블에 입력
--입사년도가 2015년 이후 입사한 사원은 test02 테이블에 입력
-->커서
-->조건문(IF문)
-->INSERT문

CREATE TABLE test01
AS
    SELECT employee_id, first_name, hire_date
    FROM employees
    WHERE employee_id = 0;

CREATE TABLE test02
AS
    SELECT employee_id, first_name, hire_date
    FROM employees
    WHERE employee_id = 0;

select * from test01;
select * from test02;

-- 1-1) 명시적 커서 + 기본 LOOP 사용
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, hire_date
        FROM employees;
    
    emp_record emp_cursor%ROWTYPE;
BEGIN
    OPEN emp_cursor;
    
    LOOP
        FETCH emp_cursor INTO emp_record;
        EXIT WHEN emp_cursor%NOTFOUND;
        -- 커서가 가리키는 한행을 기준으로 실행하고자 하는 부분  
        IF TO_CHAR(emp_record.hire_date, 'yyyy') <= '2015' THEN
            INSERT INTO test01 ( employee_id, first_name, hire_date )
            VALUES ( emp_record.employee_id, emp_record.first_name, emp_record.hire_date );
        ELSE
            INSERT INTO test02
            VALUES emp_record;
        END IF;  
    END LOOP;
    
    CLOSE emp_cursor;

END;
/


-- 1-2) 커서 FOR LOOP 사용
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, hire_date
        FROM employees;

BEGIN
    FOR emp_record IN emp_cursor LOOP        
       IF TO_CHAR(emp_record.hire_date, 'yyyy') <= '2015' THEN
            INSERT INTO test01 ( employee_id, first_name, hire_date )
            VALUES ( emp_record.employee_id, emp_record.first_name, emp_record.hire_date );
        ELSE
            INSERT INTO test02
            VALUES emp_record;
        END IF;
    END LOOP;
END;
/

--문제풀이 2.
--부서번호를 입력할 경우(&치환변수 사용) 해당하는 부서의 사원이름, 입사일자, 부서명 출력
--(단, cursor 사용)

DECLARE

    CURSOR  dept_emp_cursor  IS
    SELECT e.last_name, e.hire_date, d.department_name
    FROM employees e
        JOIN departments d --'모든' 이 아니라서 OUTER 말고 INNER JOIN 사용
        ON e.department_id = d.department_id
    WHERE e.department_id = &부서번호; --부서번호는 조건이 없더라도 커서 사용되어야 함
    
    v_emp_info dept_emp_cursor%ROWTYPE;

BEGIN
    OPEN dept_emp_cursor ;
    
    LOOP
        FETCH  dept_emp_cursor INTO  v_emp_info ;
        EXIT WHEN dept_emp_cursor%NOTFOUND ;
        
        DBMS_OUTPUT.PUT('사원이름 : ' || v_emp_info.last_name);
        DBMS_OUTPUT.PUT(', 입사일 : ' || v_emp_info.hire_date);
        DBMS_OUTPUT.PUT_LINE(', 부서이름 : ' ||v_emp_info.department_name); 
        
    END LOOP;
    
    CLOSE dept_emp_cursor ;

END;
/

-- 문제를 더 꼬아서 낼 수도 있음 (커서 추가하고 기존 LOOP 문 응용)
DECLARE
    CURSOR dept_cursor IS
        SELECT *
        FROM departments;

    CURSOR dept_emp_cursor (p_dept_id employees.department_id%TYPE) IS -- 매개변수 추가
        SELECT e.last_name, e.hire_date, d.department_id
        FROM employees e
        JOIN departments d ON e.department_id = d.department_id
        WHERE e.department_id = p_dept_id;
        
        v_emp_info dept_emp_cursor%ROWTYPE;

BEGIN
    FOR dept_info IN dept_cursor LOOP
        DBMS_OUTPUT.PUT_LINE('====현재 부서 정보 : ' || dept_info.department_name);
        OPEN dept_emp_cursor(dept_info.department_id); -- 커서 열 때 부서 ID를 전달
        
        LOOP
            FETCH dept_emp_cursor INTO v_emp_info;
            EXIT WHEN dept_emp_cursor%NOTFOUND;
            
            DBMS_OUTPUT.PUT('사원이름 : ' || v_emp_info.last_name);
            DBMS_OUTPUT.PUT('입사일: ' || v_emp_info.hire_date);
            DBMS_OUTPUT.PUT_LINE('부서 ID : ' || v_emp_info.department_id);
        END LOOP;
        
        IF dept_emp_cursor%ROWCOUNT = 0 THEN
            DBMS_OUTPUT.PUT_LINE('현재 소속된 사원이 없습니다.');
        END IF;
        
        CLOSE dept_emp_cursor;
    END LOOP;
END;
/

--예외 처리
-- 1) Oracle 이 관리하고 있고 이름이 존재하는 경우 (약 20개 정도)
DECLARE
    v_ename employees.last_name%TYPE;
BEGIN
    SELECT last_name
    INTO v_ename
    FROM employees
    WHERE department_id = &부서번호;
    
    DBMS_OUTPUT.PUT_LINE(v_ename);

EXCEPTION
    WHEN TOO_MANY_ROWS THEN
         DBMS_OUTPUT.PUT_LINE('해당 부서는 여러명의 사원이 존재합니다.');
    WHEN NO_DATA_FOUND THEN
         DBMS_OUTPUT.PUT_LINE('해당 부서에는 근무하는 사원이 존재하지 않습니다.');    
    WHEN OTHERS THEN --위에 특정된 에러 빼고 나머지 처리
         DBMS_OUTPUT.PUT_LINE('기타 예외가 발생했습니다.'); --0입력하면 문구 확인 가능
    
    DBMS_OUTPUT.PUT_LINE('EXCEPTION 절이 실행되었습니다.');
        
END;
/

-- 2) Oracle이 관리하고 있고 이름이 존재하지 않는 경우
DECLARE
    e_emps_remaining EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_emps_remaining, -02292); --(이름, 오류코드)

BEGIN
    DELETE FROM departments
    WHERE department_id = &부서번호;
EXCEPTION
    WHEN e_emps_remaining THEN --예외 트랩 진행
        DBMS_OUTPUT.PUT_LINE('다른 테이블에서 사용하고 있습니다.');
END;
/

-- 3) 사용자가 정의하는 예외사항
DECLARE
    e_emp_del_fail EXCEPTION;
BEGIN
    DELETE FROM test_employees
    WHERE employee_id = &사원번호;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE e_emp_del_fail;
    END IF;
EXCEPTION
    WHEN e_emp_del_fail THEN
        DBMS_OUTPUT.PUT_LINE('해당 사원이 존재하지 않습니다.');
END;
/

-- 예외 트랩 함수 (학생공유)
DECLARE
    e_too_many EXCEPTION;
    
    v_ex_code NUMBER;
    v_ex_msg VARCHAR2(1000);
    emp_info employees%ROWTYPE;
BEGIN
    SELECT *
    INTO emp_info
    FROM employees
    WHERE department_id = &부서번호;
    
    IF emp_info.salary < (emp_info.salary * emp_info.commission_pct + 10000) THEN
        RAISE e_too_many;
    END IF;
EXCEPTION
    WHEN e_too_many THEN
        DBMS_OUTPUT.PUT_LINE('사용자 정의 예외 발생!');
    WHEN OTHERS THEN
        v_ex_code := SQLCODE;
        v_ex_msg := SQLERRM;
        DBMS_OUTPUT.PUT_LINE('ORA ' || v_ex_code);
        DBMS_OUTPUT.PUT_LINE(' - ' || v_ex_msg);
END;
/

--1) test employees 테이블을 사용하여 선택된 사원을 삭제하는 Pl/SQL 작성.
--조건1. 치환변수 사용. 조건2.사원이 존재하지 않는 경우 '해당 사원이 존재하기 않습니다.' 라는 메세지 출력
-->사용자 정의 예외
DECLARE
    
BEGIN

END;
/


--PROCEDURE
--호출 2가지. PL/SQL 에서만 실행해야 함.
CREATE PROCEDURE test_pro
IS
--DECLARE 선언부. 보이지는 않지만 공간은 차지하고있음. 내부에서 사용하는 변수, 커서, 타입, 예외 선언 가능.
    v_msg VARCHAR2(100) := 'Execute Procedure';
    
BEGIN
    DELETE FROM test_employees
    WHERE department_id = 50; --치환변수 사용 불가능. 그냥 상수값 써라
    
    DBMS_OUTPUT.PUT_LINE(v_msg);
EXCEPTION
    WHEN INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('사용할 수 없는 커서입니다');    
END;
/

--프로시저 실행 (1)
BEGIN
    test_pro;
END;
/

--프로시저 실행 (2. 단축명령어)
EXECUTE test_pro; 


--IN : 프로시저 내부에서 상수로 인식함

DROP PROCEDURE raise_salary; --수정사항 생기면 드랍하고 다시 생성하기.

CREATE PROCEDURE raise_salary
(p_eid IN employees.employee_id%TYPE) --매개변수 2개 정해주기. (이름, 데이터타입) 사이즈는 없음
IS

BEGIN
    --p_eid := 100;    
    UPDATE employees
    SET salary = salary * 1.1
    WHERE employee_id = p_eid;
END;
/

--위에 만든 거 실행해보자
DECLARE
    v_first NUMBER(3,0) := 100;
    v_second CONSTANT NUMBER(3,0) :=149;
BEGIN
    raise_salary(103);
    raise_salary((120+10));
    raise_salary(v_second);
    raise_salary(v_first); --어떤 형태든 값만 넘겨주면 실행된다.
END;
/

SELECT employee_id, salary
FROM employees;


--OUT : 프로시저 내부에서 초기화되지 않은 변수로 인식. 값 전달은 불가능..

CREATE PROCEDURE test_p_out
(p_num IN NUMBER,
p_result OUT NUMBER)
IS
    v_sum NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('IN : ' || p_num);
    DBMS_OUTPUT.PUT_LINE('OUT : ' || p_result);
    
    v_sum := p_num + p_result;
    p_result := v_sum;
    
END;
/

DECLARE
    v_result NUMBER(4,0) := 1234;
BEGIN
    test_p_out(1000, v_result); --2개 넘기면서 프로시저 호출
    DBMS_OUTPUT.PUT_LINE('result : ' || v_result);    
END;
/

-- 적용..?

DROP PROCEDURE select_emp;

CREATE PROCEDURE select_emp
(p_eid IN employees.employee_id%TYPE,
 p_ename OUT employees.last_name%TYPE,
 p_sal OUT employees.salary%TYPE,
 p_comm OUT employees.commission_pct%TYPE)
IS

BEGIN
    SELECT last_name, salary, NVL(commission_pct, 0)
    INTO p_ename, p_sal, p_comm
    FROM employees
    WHERE employee_id = p_eid;
END;
/
DECLARE
    v_name VARCHAR2(100 char);
    v_sal NUMBER;
    v_comm NUMBER;

    v_eid NUMBER := &사원번호;
BEGIN
    select_emp(v_eid, v_name, v_sal, v_comm);
    
    DBMS_OUTPUT.PUT('사원번호 : ' || v_eid);
    DBMS_OUTPUT.PUT(', 사원이름 : ' || v_name);
    DBMS_OUTPUT.PUT(', 급여 : ' || v_sal);
    DBMS_OUTPUT.PUT_LINE(', 커미션 : ' || v_comm);
END;
/


--IN OUT 매개변수 (포맷변환을 많이 씀) 0으로 시작하는 숫자값들 주의.. 
-- '01012341234 => '010-1234-1234'
CREATE PROCEDURE format_phone
(p_phone_no IN OUT VARCHAR2) --번호라고 다 NUMBER 아님.
IS

BEGIN
    p_phone_no := SUBSTR(p_phone_no, 1, 3) --SUBSTR는 자르는거
                || '-'|| SUBSTR(p_phone_no, 4, 4)
                || '-'|| SUBSTR(p_phone_no, 8); --8자리부터 마지막까지
END;
/

DECLARE
    v_ph_no VARCHAR2(100) := '01012341234';
BEGIN
    DBMS_OUTPUT.PUT_LINE('1) ' || v_ph_no);
    format_phone(v_ph_no);
    DBMS_OUTPUT.PUT_LINE('2) ' || v_ph_no);
END;
/

--원데이터 보존하려면 IN OUT 따로따로 쓰는 게 나음...

--SUBSTR (예제_기본키. 수업 내용이랑은 상관X)

SELECT NVL(MAX(employee_id),0) + 1
FROM employees; --이런 예시?

CREATE TABLE var_pk_tbl
(
    no VARCHAR2(1000) PRIMARY KEY,
    name VARCHAR2(4000) DEFAULT 'anony'
);

'TEMP240215101'  -- TEMP + yyMMdd + 숫자(항상 3자리로 유지... 안되면 카운팅되게)
SELECT no, name
FROM var_pk_tbl;

INSERT INTO var_pk_tbl(no, name)
VALUES ('TEMP240215101', '상품01');


SELECT 'TEMP' || TO_CHAR(sysdate, 'yyMMdd') || LPAD(NVL(MAX(SUBSTR(no, -3)), 0)+1,3,'0') --''0' 은 00으로 채우겠다...
FROM var_pk_tbl
WHERE SUBSTR(no, 5, 6) = TO_CHAR(sysdate, 'yyMMdd');


--프로시저 문제풀기 1~5 (변수 사용 불가...)
/*
1.
주민등록번호를 입력하면 다음과 같이 출력되도록 yedam_ju 프로시저를 작성하시오.
EXECUTE yedam_ju(9501011667777)
EXECUTE yedam_ju(1511013689977)
 -> 950101-1******
*/

--프로시저, IN 매개변수 하나

CREATE OR REPLACE PROCEDURE yedam_ju
(p_ssn IN VARCHAR2) 
IS
--선언부 : 내부에서 사용할 변수, 타입, 커서 등
    v_result VARCHAR2(100);
BEGIN
    --v_result := SUBSTR(p_ssn, 1, 6) || '-'|| SUBSTR(p_ssn, 7, 1) || '******'
    v_result := SUBSTR(p_ssn, 1, 6) || '-'|| RPAD(SUBSTR(p_ssn, 7, 1),7,'*'); --(들고있는글자, 출력하고자하는 자리수, 대체할 문자?)
    DBMS_OUTPUT.PUT_LINE(v_result);
    
END;
/
EXECUTE yedam_ju('0501001111111'); --이걸로...






/*
2.
사원번호를 입력할 경우 삭제하는 TEST_PRO 프로시저를 생성하시오.
단, 해당사원이 없는 경우 "해당사원이 없습니다." 출력
예) EXECUTE TEST_PRO(176)
*/






/*
3.
다음과 같이 PL/SQL 블록을 실행할 경우 
사원번호를 입력할 경우 사원의 이름(last_name)의 첫번째 글자를 제외하고는
'*'가 출력되도록 yedam_emp 프로시저를 생성하시오. +length 결합하면 풀이 쉬워질듯...

실행) EXECUTE yedam_emp(176)
실행결과) TAYLOR -> T*****  <- 이름 크기만큼 별표(*) 출력
*/






/*
4.
부서번호를 입력할 경우 
해당부서에 근무하는 사원의 사원번호, 사원이름(last_name)을 출력하는 get_emp 프로시저를 생성하시오. 
(cursor 사용해야 함)
단, 사원이 없을 경우 "해당 부서에는 사원이 없습니다."라고 출력(exception 사용)
실행) EXECUTE get_emp(30)
*/






/*
5.
직원들의 사번, 급여 증가치만 입력하면 Employees테이블에 쉽게 사원의 급여를 갱신할 수 있는 y_update 프로시저를 작성하세요. 
만약 입력한 사원이 없는 경우에는 ‘No search employee!!’라는 메시지를 출력하세요.(예외처리)
실행) EXECUTE y_update(200, 10)
*/





